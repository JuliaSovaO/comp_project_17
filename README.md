# **Звіт з комп’ютерного проекту для роботи з графами**

# **Учасники команди та їх функції**

- Куриляк Данило: Реалізація функцій читання/запису графа
- Софія Сичак: Реалізація пошуку компонент зв'язності
- Пенський Ерік: Реалізація пошуку в глибину
- Пастернак Марко: Реалізація пошуку точок з'єднання
- Сова Юлія: Реалізація пошуку мостів

# **Мета проекту**

Розробка набору функцій для роботи з графами, включаючи:

- Зчитування та запис графів у файл
- Аналіз зв'язності графа
- Пошук важливих структурних елементів (точки з'єднання, мости)
- Реалізація алгоритму пошуку в глибину

# **Опис реалізованих функцій**

## Функції read_graph та write_graph_to_file (Куриляк Данило)

У функції read_graph() реалізовано перетворення графа з текстового представлення у матрицю суміжності. Матриця суміжності - це один з основних способів представлення графа(а також тема, яку ми зараз вивчаємо ;) ), де кожен елемент матриці показує наявність (1) або відсутність (0) зв'язку між вершинами. Код спочатку зчитує ребра графа з файлу та зберігає їх у множині, що гарантує унікальність кожного ребра, оскільки в теорії графів одне й те саме ребро не може повторюватися.

З неорієнтованим графом (параметр is_directed=False), використовується важливий принцип симетричності - якщо вершина А з'єднана з вершиною Б, то і вершина Б з'єднана з вершиною А. Тому в матриці суміжності встановлюється значення 1 симетрично відносно головної діагоналі.

У функції write_graph_to_file() Данило виконанав зворотне перетворення - з матриці суміжності у список ребер. В ній використано принцип перебору всіх можливих пар вершин та перевірки наявності зв'язку між ними. Для неорієнтованого графа враховується, що ребра (1,2) та (2,1) представляють один і той самий зв'язок, тому використовується множина written_edges для уникнення дублікатів.

Важливим елементом є обробка помилок - перевіряється коректність формату даних у файлі. Це забезпечує надійність роботи програми навіть при некоректних вхідних даних.

## Функції ‎find_connectivity, is_directed_graph, make_undirected, dfs (Софія Сичак)

Функція find_connectivity визначає всі зв’язні компоненти у графі. Вона працює як для неорієнтованих, так і для орієнтованих графів (у випадку орієнтованих графів розглядається слабка зв’язність).
(Аргументи і тд описано в документації)
Створено 3 допоміжні функції:

- is_directed_graph(graph)
- make_undirected(graph)
- dfs(node, component)

Функція складається з кількох етапів:

1. Перевірка орієнтованості графа:
Визначається, чи є граф орієнтованим за властивістю симетричності матриці суміжності.
2. Перетворення графа на неорієнтований:
Якщо граф орієнтований, його матриця суміжності модифікується, щоб врахувати всі зв’язки.
3. Пошук зв’язних компонент:
Використовується алгоритм глибини (DFS) для обходу графа і знаходження всіх зв’язних компонент.
Властивість симетричності матриці суміжності:
• Матриця суміжності неорієнтованого графа симетрична відносно головної діагоналі. Якщо ця властивість порушується, граф є орієнтованим.
• Для визначення слабкої зв’язності орієнтованого графа додаються всі симетричні зв’язки, тобто відбувається симетричне замикання.
DFS (пошук у глибину) використовується для обходу графа і пошуку всіх вершин, що належать до однієї зв’язної компоненти. Під зв’язною компонентою мається на увазі підмножина вершин графа, в якій будь-яка вершина пов'язана з будь-якою іншою через шлях, і яка є максимальною за цією властивістю. У цій функції ці підмножини графа репрезентується як списки у списку.
Алгоритм, використаний для dfs:
DFS стартує з однієї вершини, рекурсивно відвідує всіх сусідів цієї вершини, які ще не були відвідані. Таким чином, під час одного запуску DFS визначається одна зв’язна компонента. Функція працює рекурсивно.
Потім для кожної невідвіданої вершини викликається dfs через цикл for, який знову проходиться по графу. Під час кожного ‘обходу’ dfs створюється список, який фінально додається у список components.

## Функції dfs_kosaraju, transp_graph, find_strong_connectivity (Пенський Ерік)

Функція dfs_kosaraju - допоміжна функція для заповнення стеку у зворотньому порядку обходу вершин у алгоритмі косараджу. Ця функція позначає пройдені вершини за 'True', а потім додає вершини у стек. Це називається DFS (deep first search), в процесі якого алгоритм проходиться по максимальній кількості вершин за раз так, щоб вони всі були зв'язані між собою. Якщо алгоритм не може знайти шлях від однієї вершини до іншої - він переключається на будь-яку іншу вершину і так поки він не пройде всі вершини.
Функція transp_graph робить з заданого графа траспонований, міняючи напрямки кожної вершини на протилежний (наприклад 2 -> 3 на 3->2).
Функція find_strong_connectivity_kosaraju проходить спочатку DFS на простому графі, заповнюючи стек, а потім у порядку заповнення стеку проходить DFS по транспонованому графу, після чого набір відвіданих вершин дасть нам компоненту сильної зв'язності.

- Нехай G орієнтований граф і S порожній [стек](https://uk.wikipedia.org/wiki/%D0%A1%D1%82%D0%B5%D0%BA).
- Допоки S не містить всі вершини:
    - Вибрати довільну вершину *v* не з S. Виконати [пошук в глибину](https://uk.wikipedia.org/wiki/%D0%9F%D0%BE%D1%88%D1%83%D0%BA_%D0%B2_%D0%B3%D0%BB%D0%B8%D0%B1%D0%B8%D0%BD%D1%83) від *v*. По завершені пошуку в глибину для кожної вершини *u*, заштовхуємо *u* на S.
- Обернути всі ребра для отримання транспонованого графа.
- Доки S непорожній (містить вершину в порядку завершення, на верхівці стека — останнє завершення пошуку в глибину):
    - Виштовхнути вершину *v* з S. Виконати пошук в глибину від *v*. Набір відвіданих вершин дасть компоненту сильної зв'язності, що містить *v*; записати це і видалити всі ці вершини з графа G і стека S. Так само можна використати [пошук в ширину](https://uk.wikipedia.org/wiki/%D0%9F%D0%BE%D1%88%D1%83%D0%BA_%D0%B2_%D1%88%D0%B8%D1%80%D0%B8%D0%BD%D1%83).

## Функції deep_first_search, find_connection_points, find_connection_points_optimized, find_function_runtime (Пастернак Марко)

Марко реалізував 2 функції знаходження точок сполучення. Перша функціє є не дуже ефективною, адже вона шукає точки сполучення видаляючи почергово кожну вершину і перевіряючи чи збільшилась кількість компонент зв'язності. Це є не ефективно тому, що для визначення компонент зв'язності потрібно кожен раз робити обхід графа в глибину, що робить час виконання програми набагато довшим. Проте є інший алгоритм, алгоритм Тар'яна, в якому для знаходження шарнірів достатньо лиш одного обходу графа в глибину. Під час обходу графа ми для кожної вершини визначаємо її порядковий номер - час коли ми перший раз прийшли у цю вершину, а також визначаємо low - мінімальний порядковий номер серед усіх суміжних вершин. Для того, щоб мати можливість повернутися назад ми кожну вершину, в яку ми прийшли записуємо в stack. Якщо нам доведеться повертатися в вершину з якої ми прийшли ми видаляємо останню вершину зі стеку і переходимо в останню вершину, яка залишилася. Після того як ми знайшли порядковий номер і low кожної вершини ми можемо визначити точки сполучення. Якщо початкова вершина має більше одного нащадка то вона є шарніром. Будь-яка інша вершина І буде шарніром якщо хоча б одна вершина суміжна з І буде мати low рівний порядковому номеру вершини І. Також Марко розробив функцію, яка дозволяє порівняти швидкість роботи цих алгоритмів і вона наочно показує, що алгоритм Тар'яна є набагато швидшим.

## Функції find_bridges, find_bridges_dfs, argprs, main (Сова Юлія)

Функція find_bridges знаходить мости в неорієнтованому графі, видаляючи кожне ребро й перевіряючи зміну кількості компонент зв’язності. Її алгоритм досить простий, оскільки полягає в послідовному видаленні ребер та перевірці, чи не збільшилась кількість компонент графа. Однак тестування довело, що це не зовсім ефективно для досить великих графів. З метою зменшити час пошуку мостів була розроблена функція find_bridges_dfs, яка натомість використовує алгоритм Тар’яна, і за один обхід графа в глибину визначає всі мости.

Функція find_bridges_dfs використовує оптимізований підхід на основі алгоритму Тар’яна, де за один обхід графа в глибину визначаються всі мости. Кожній вершині присвоюються два значення: discovery[u] — час відвідування вершини, та low[u] — найменший час, до якого можна дістатися через зворотні ребра. Під час обходу для кожної вершини перевіряються суміжні. Якщо суміжна вершина ще не відвідана, виконується DFS для неї, після чого оновлюється значення low[u] для поточної вершини. Якщо low[v] > discovery[u], то ребро між u та v є мостом, тобто його видалення роз’єднує граф.

Функція argprs обробляє командні аргументи, дозволяючи вказувати вхідний/вихідний файл, тип графа (орієнтований чи ні) та завдання (read, write, components, strong_components, connection_points, bridges).  

Функція main виконує обрані користувачем завдання на основі аргументів. Залежно від задачі, викликаються відповідні функції: читання, запис графа, пошук компонент зв’язності, сильних компонент, точок сполучення або мостів. Така структура забезпечує гнучкість і легкість у використанні бібліотеки.  


# **Висновок**

Практичне застосування теоретичних знань:

- Успішно застосовано принципи теорії графів
- Реалізовано основні алгоритми роботи з графами
- Продемонстровано розуміння структур даних та їх ефективного використання

Командна робота:

- Успішно розподілено та виконано завдання між членами команди
- Налагоджено ефективну комунікацію в команді
- Кожен учасник зробив значний внесок у проєкт

# **Відгук про проєкт**

Позитивні аспекти:

- Практичний досвід розробки реального програмного забезпечення
- Можливість застосувати теоретичні знання з дискретної математики
- Розвиток навичок командної роботи

Складнощі:

- Координація роботи команди
- Забезпечення єдиного стилю коду
- Інтеграція різних частин проєкту

**Фідбек для викладачів та асистентів**

- Проєкт ефективно допомагає закріпити теоретичні знання
- Командна робота сприяє розвитку soft skills
- Практичний досвід роботи з GitHub є дуже корисним
- Чіткі вимоги до проєкту допомагають у структуруванні роботи

Проєкт успішно досяг своєї мети - перевірки та закріплення знань з дискретної математики, розвитку практичних навичок програмування та командної роботи. Кожен учасник команди отримав цінний досвід розробки програмного забезпечення та роботи в команді.
